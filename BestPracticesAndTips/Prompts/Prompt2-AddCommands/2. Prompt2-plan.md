# Implementation Plan: CRUD Commands and Enhanced Use Cases

## Current System Analysis

The BestPracticesAndTips application follows Clean Architecture principles with:

**Domain Layer**: Customer, Order, Product, OrderItem entities with rich domain behaviors
**Application Layer**: Use cases using MediatR pattern, DTOs, and repository interfaces
**Infrastructure Layer**: EF Core repositories, in-memory database, configurations
**Presentation Layer**: Minimal API endpoints with proper HTTP verbs and status codes

**Current Capabilities**:
- Customer: Create, GetById, GetAll (query operations)
- Product: GetById, GetAll (query operations only)
- Order: GetAll (query operations only)

## Phase 1: Complete CRUD Operations

### 1.1 Customer Commands

#### Update Customer Command
- **Location**: `Application/UseCases/Customers/UpdateCustomer.cs`
- **Endpoint**: PUT `/api/customers/{id}`
- **Features**: Update customer details (excluding email), validate customer exists
- **Domain Logic**: Use Customer.UpdatedAt property tracking

#### Delete Customer Command (Soft Delete)
- **Location**: `Application/UseCases/Customers/DeleteCustomer.cs`
- **Endpoint**: DELETE `/api/customers/{id}`
- **Features**: Soft delete using Customer.Deactivate(), validate no active orders
- **Business Rules**: Cannot delete customers with pending/shipped orders

### 1.2 Product Commands

#### Create Product Command
- **Location**: `Application/UseCases/Products/CreateProduct.cs`
- **Endpoint**: POST `/api/products`
- **Features**: Create new product, validate unique SKU
- **Domain Logic**: Auto-generate SKU if not provided, validate pricing

#### Update Product Command
- **Location**: `Application/UseCases/Products/UpdateProduct.cs`
- **Endpoint**: PUT `/api/products/{id}`
- **Features**: Update product details, track stock changes
- **Business Rules**: Cannot reduce stock below reserved quantities

#### Delete Product Command (Soft Delete)
- **Location**: `Application/UseCases/Products/DeleteProduct.cs`
- **Endpoint**: DELETE `/api/products/{id}`
- **Features**: Soft delete using Product.Deactivate()
- **Business Rules**: Cannot delete products with pending orders

#### Update Stock Command
- **Location**: `Application/UseCases/Products/UpdateStock.cs`
- **Endpoint**: PATCH `/api/products/{id}/stock`
- **Features**: Adjust stock levels (increase/decrease)
- **Domain Logic**: Use Product.UpdateStock() method

### 1.3 Order Commands

#### Create Order Command
- **Location**: `Application/UseCases/Orders/CreateOrder.cs`
- **Endpoint**: POST `/api/orders`
- **Features**: Create order with items, validate inventory, calculate totals
- **Domain Logic**: Use OrderDomainService for complex business rules

#### Update Order Command
- **Location**: `Application/UseCases/Orders/UpdateOrder.cs`
- **Endpoint**: PUT `/api/orders/{id}`
- **Features**: Update order details (limited based on status)
- **Business Rules**: Restrict updates based on OrderStatus

#### Cancel Order Command
- **Location**: `Application/UseCases/Orders/CancelOrder.cs`
- **Endpoint**: POST `/api/orders/{id}/cancel`
- **Features**: Cancel order, restore inventory
- **Domain Logic**: Use Order.CancelOrder(), restore product stock

#### Ship Order Command
- **Location**: `Application/UseCases/Orders/ShipOrder.cs`
- **Endpoint**: POST `/api/orders/{id}/ship`
- **Features**: Mark order as shipped, set shipped date
- **Domain Logic**: Use Order.ShipOrder(), validate order status

#### Complete Order Command
- **Location**: `Application/UseCases/Orders/CompleteOrder.cs`
- **Endpoint**: POST `/api/orders/{id}/complete`
- **Features**: Mark order as completed
- **Business Rules**: Can only complete shipped orders

## Phase 2: Enhanced Use Cases

### 2.1 Customer Analytics Use Case
- **Location**: `Application/UseCases/Customers/GetCustomerAnalytics.cs`
- **Endpoint**: GET `/api/customers/{id}/analytics`
- **Features**: Customer lifetime value, order history summary, favorite products
- **Domain Logic**: Aggregate order data, calculate metrics

### 2.2 Product Catalog Management
- **Location**: `Application/UseCases/Products/GetProductCatalog.cs`
- **Endpoint**: GET `/api/products/catalog`
- **Features**: Paginated product listing with filtering by category, price range, availability
- **Query Parameters**: page, size, category, minPrice, maxPrice, inStockOnly

### 2.3 Low Stock Alert System
- **Location**: `Application/UseCases/Products/GetLowStockProducts.cs`
- **Endpoint**: GET `/api/products/low-stock`
- **Features**: Identify products below reorder threshold
- **Business Logic**: Configurable threshold, prioritize by sales velocity

### 2.4 Order Status Tracking
- **Location**: `Application/UseCases/Orders/GetOrderStatusHistory.cs`
- **Endpoint**: GET `/api/orders/{id}/status-history`
- **Features**: Track order status changes over time
- **Implementation**: Enhance BaseEntity with audit trail or create OrderStatusHistory entity

### 2.5 Sales Reporting
- **Location**: `Application/UseCases/Reports/GetSalesReport.cs`
- **Endpoint**: GET `/api/reports/sales`
- **Features**: Sales analytics by period, top products, customer segments
- **Query Parameters**: startDate, endDate, groupBy (daily/weekly/monthly)

## Phase 3: Replace MediatR with Custom Solution

### 3.1 Complete MediatR Removal
- **Remove**: MediatR NuGet package and all references
- **Remove**: All `IRequest`, `IRequestHandler` implementations
- **Replace**: Direct dependency injection of use case handlers
- **Update**: Program.cs to register handlers directly with DI container

### 3.2 Direct Use Case Pattern
- **Pattern**: Direct injection of use case handlers into endpoints
- **Structure**: Each use case becomes a standalone service with clear interface
- **Registration**: Simple DI registration without mediator abstraction
- **Benefits**: Simpler, more explicit dependencies, easier debugging

### 3.3 Use Case Handler Structure
```csharp
// Use Case Interface
public interface ICreateCustomerUseCase
{
    Task<CustomerDto> ExecuteAsync(CreateCustomerDto customer, CancellationToken cancellationToken = default);
}

// Use Case Implementation
public class CreateCustomerUseCase(ICustomerRepository customerRepository) : ICreateCustomerUseCase
{
    public async Task<CustomerDto> ExecuteAsync(CreateCustomerDto customer, CancellationToken cancellationToken = default)
    {
        // Implementation logic
    }
}
```

### 3.4 Endpoint Integration
- **Pattern**: Direct injection of use case services into endpoints
- **Simplification**: Remove command/query wrappers, use DTOs directly
- **Example**: `app.MapPost("/api/customers", async (ICreateCustomerUseCase useCase, CreateCustomerDto dto) => ...)`

### 3.5 Implementation Benefits
- **Zero external dependencies**: No MediatR package required
- **Explicit dependencies**: Clear service contracts
- **Simplified debugging**: Direct call chain without mediator abstraction
- **Better performance**: No reflection or pipeline overhead

## Phase 4: Technical Implementation Details

### 4.1 Use Case Structure Pattern (Without MediatR)
```csharp
// Use Case Interface
public interface IUpdateCustomerUseCase
{
    Task<CustomerDto> ExecuteAsync(int id, UpdateCustomerDto customer, CancellationToken cancellationToken = default);
}

// Use Case Implementation
public class UpdateCustomerUseCase(ICustomerRepository customerRepository) : IUpdateCustomerUseCase
{
    public async Task<CustomerDto> ExecuteAsync(int id, UpdateCustomerDto customer, CancellationToken cancellationToken = default)
    {
        // Implementation with domain logic
    }
}

// Endpoint Usage
group.MapPut("/{id:int}", async (IUpdateCustomerUseCase useCase, int id, UpdateCustomerDto dto) =>
{
    var result = await useCase.ExecuteAsync(id, dto);
    return Results.Ok(result);
});
```

### 4.2 Error Handling Strategy
- **Domain Exceptions**: Create custom exceptions for business rule violations
- **Validation**: Add FluentValidation for command validation
- **Response Wrapper**: Enhance ApiResponse model for consistent error formatting

### 4.3 Cross-Cutting Concerns

#### Validation Strategy
- **Approach**: Direct validation in use case services using FluentValidation
- **Implementation**: Inject validators into use case constructors
- **Location**: `Application/Common/Validators/`

#### Logging Strategy
- **Approach**: Direct logging in use case services using ILogger<T>
- **Implementation**: Inject ILogger into use case constructors
- **Features**: Log use case execution, performance metrics

#### Unit of Work Pattern
- **Enhancement**: Implement IUnitOfWork for transactional consistency across repositories
- **Integration**: Inject into use cases that require multi-repository transactions

### 4.4 Database Enhancements

#### Audit Trail
- **Enhancement**: Extend BaseEntity with audit properties
- **Implementation**: Automatic CreatedBy/UpdatedBy population via EF interceptors

#### Soft Delete Global Filter
- **Location**: `Infrastructure/Data/ApplicationDbContext.cs`
- **Implementation**: Global query filter for soft-deleted entities

## Phase 5: Repository Enhancements

### 5.1 Generic Repository Extensions
```csharp
// Add to IRepository<T>
Task<T?> GetByIdWithIncludeAsync<TProperty>(int id, Expression<Func<T, TProperty>> include);
Task<IEnumerable<T>> GetPagedAsync(int page, int size, Expression<Func<T, bool>>? filter = null);
Task<int> CountAsync(Expression<Func<T, bool>>? filter = null);
```

### 5.2 Specialized Repository Methods
- **ICustomerRepository**: GetByEmailAsync, GetCustomersWithOrdersAsync
- **IProductRepository**: GetBySkuAsync, GetLowStockProductsAsync, GetByCategoryAsync
- **IOrderRepository**: GetByCustomerIdAsync, GetByStatusAsync, GetOrdersInDateRangeAsync

## Phase 6: API Enhancements

### 6.1 Endpoint Improvements
- **Rate Limiting**: Implement rate limiting for resource-intensive endpoints

### 6.2 OpenAPI Documentation
- **Enhancement**: Add comprehensive Swagger documentation with examples
- **Request/Response Models**: Document all DTOs with validation attributes

### 6.3 Health Checks
- **Location**: `Presentation/HealthChecks/`
- **Features**: Database connectivity, external service health monitoring

## Phase 7: Testing Strategy

### 7.1 Unit Tests Structure
```
Tests/
├── Unit/
│   ├── Application/
│   │   └── UseCases/
│   │       ├── Customers/
│   │       ├── Products/
│   │       └── Orders/
│   └── Domain/
│       └── Entities/
├── Integration/
│   └── Endpoints/
└── TestUtilities/
    ├── Fixtures/
    └── Builders/
```

### 7.2 Test Coverage Areas
- **Use Case Services**: Business logic validation, error handling
- **Domain Methods**: Entity behavior testing
- **Repository Tests**: Data access layer testing
- **Endpoint Tests**: HTTP integration testing

## Implementation Priority

1. **High Priority**: Remove MediatR completely and implement direct use case pattern
2. **High Priority**: Complete Customer, Product, Order CRUD operations
3. **Medium Priority**: Enhanced use cases (analytics, reporting)
4. **Low Priority**: Advanced technical features (auditing, rate limiting)

## Success Metrics

- Complete removal of MediatR with direct use case service pattern
- All CRUD operations functional with proper validation
- Consistent error handling across all endpoints
- Comprehensive unit test coverage (>80%)
- Performance benchmarks established
- API documentation complete and accurate

This plan ensures the application follows clean architecture principles while eliminating MediatR dependency completely. The direct use case pattern provides simpler, more explicit dependencies and easier debugging. Each implementation phase builds upon previous work while maintaining separation of concerns and testability.
